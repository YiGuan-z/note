# 300è¡Œç»™ä½ ä¸€ä¸ªå°å‹Iocå®¹å™¨

æœ¬æ–‡ä¸“ä¾›äº ~~æ–°æ‰‹~~ å…¥é—¨ğŸ¤”

ï¼ˆä»£ç å»æ‰æ³¨é‡Šè¿ä¸‰ç™¾è¡Œéƒ½æ²¡æœ‰å“¦ï¼‰ğŸ˜

ï¼ˆå†å»æ‰ä¸€äº›æ— å…³å†…å®¹ï¼Œé¢„è®¡å¾—å‡åŠï¼‰ğŸ˜

## æ³¨æ„

- ä»…ä¾›å‚è€ƒï¼Œä»¥é˜æ˜Iocå®¹å™¨åˆ°åº•æ˜¯ä¸ªä»€ä¹ˆä¸œè¥¿ï¼Œä»¥åŠå°è¯•ç¼–å†™ä¸€ä¸ªå°å‹çš„Iocå®¹å™¨ã€‚
- streamåˆ°å¤„éƒ½æ˜¯ï¼Œéœ€è¦ç†è§£streamå¦‚ä½•ä½¿ç”¨ã€‚
- éœ€è¦ç†è§£ä¸€ä¸‹å‡½æ•°å¼ç¼–ç¨‹ã€‚
  - å…¶å®ä¹Ÿå¾ˆç®€å•ï¼Œæœ¬è´¨ä¸Šæ˜¯åœ¨å¯¹è±¡ä¸­ä¿å­˜äº†ä¸€æ®µä»£ç ï¼Œä»¥ä¾›éœ€è¦æ—¶è¿è¡Œã€‚
  - åˆå› ä¸ºä¸€ç³»åˆ—çš„ç®€åŒ–è§„åˆ™ï¼Œæ‰€ä»¥çœ‹ä¸Šå»å¯èƒ½æœ‰ç‚¹ä¸æ˜æ‰€ä»¥ã€‚
- ä½¿ç”¨äº†é«˜ç‰ˆæœ¬çš„Javaç‰¹æ€§ï¼Œå¦‚æœä¸æ”¯æŒè¯¥ç‰¹æ€§ï¼Œå»é™¤å³å¯ï¼Œæˆ‘ä¼šåœ¨ä»£ç ä¸­æ³¨æ˜ã€‚

## æ­£æ–‡

ç”±äºSpringæ¡†æ¶åœ¨Javaå†å²ä¸­å æ®äº†ä¸¾è¶³è½»é‡çš„åœ°ä½ï¼Œè°ˆåŠIocå®¹å™¨å°±é¿å…ä¸äº†å®ƒã€‚
Iocå®¹å™¨æ˜¯ä¸€ä¸ªå®ç°è‡ªåŠ¨ä¾èµ–æ³¨å…¥çš„ä¸€ä¸ªæ¡†æ¶ï¼Œå®ƒç®¡ç†å¯¹è±¡çš„åˆ›å»ºå’Œç”Ÿå‘½å‘¨æœŸï¼Œå¹¶è‡ªåŠ¨å¯»æ‰¾åˆ°ç¨‹åºä¾èµ–æ³¨å…¥åˆ°ç±»ä¸­ã€‚å¯ä»¥å°†å®ƒç†è§£ä¸ºåº”ç”¨ç¨‹åºä¸­ç»„ä»¶ä»“åº“ï¼Œä½ å¯ä»¥æä¾›ä»»ä½•ç»„ä»¶ç»™å®ƒï¼Œå®ƒé€šè¿‡ç¨‹åºå†…å®¹è‡ªåŠ¨ï¼ˆæ˜¯éœ€è¦ç¼–å†™å®šä¹‰çš„ï¼‰ç®¡ç†ç»„ä»¶ã€‚

psï¼šå½“åˆæ˜¯è½»é‡çº§ï¼Œç°åœ¨æ˜¯é‡é‡çº§+å·¨æ— éœ¸

å¯ä»¥ä¾æ®ä¸‹é¢çš„å®Œæ•´ä»£ç æ¥åˆ›å»ºä¸€ä¸ªç±»ä¼¼äºSpringçš„Iocå®¹å™¨ï¼Œåªéœ€è¦æ·»åŠ ä¸€ä¸ªåŒ…æ‰«æï¼Œä½¿ç”¨åŒ…æ‰«ææ¥æ‰«æclasså­—èŠ‚ç ï¼Œé€šè¿‡classloaderè¿›è¡ŒåŠ è½½ï¼ŒåŠ è½½å®Œæ¯•åå°±å¯ä»¥ç–¯ç‹‚éå†é‡Œé¢çš„å†…å®¹äº†ï¼Œç–¯ç‹‚éå†ï¼ä¸è¦æ‹…å¿ƒæ¶ˆè€—CPUå’Œå†…å­˜ï¼ŒCPUé€Ÿåº¦éå¸¸å¿«ï¼Œè¿™ä¹ˆç‚¹å­—èŠ‚ç å ä¸äº†å¤šå°‘å†…å­˜ã€‚

è¿‡ç¨‹å¤§è‡´ä¸º

![ioc](./image/Snipaste_2023-07-02_16-32-36.png)

### åˆ›å»ºä¾èµ–é“¾

ä¾‹å¦‚äººéœ€è¦æ‰‹æœºæ‰èƒ½å®Œæˆæ‰“ç”µè¯ï¼Œè¿™æ—¶å€™å…³ç³»å°±åº”è¯¥åƒè¿™æ ·ã€‚

```mermaid
graph TD;
    äºº-->æ‰‹æœº;
    æ‰‹æœº-->æ‰“ç”µè¯;
```

æ‰“ç”µè¯è¿™ä¸ªåŠ¨ä½œå°±éœ€è¦æ‰‹æœºæ¥å®Œæˆï¼Œæ‰‹æœºéœ€è¦äººæ¥ä½¿ç”¨ï¼Œæ‰€ä»¥æ‰“ç”µè¯è¿™ä¸ªåŠ¨ä½œçš„ä¾èµ–å…³ç³»æ˜¯ æ‰“ç”µè¯=>æ‰‹æœº =>äººã€‚

è¦åˆ›å»ºè¿™ä¹ˆä¸€ä¸ªä¾èµ–åˆ—è¡¨æ¥æ”¯æŒæ‰“ç”µè¯ï¼Œå°±éœ€è¦æ‰¾åˆ°æœ€åº•å±‚çš„é‚£ä¸ªä¾èµ–ï¼ˆäººï¼‰ï¼Œè¿™æ—¶å€™æˆ‘ä»¬å¯ä»¥é€šè¿‡æŸç§é€’å½’å½¢å¼æ¥è¿›è¡Œåˆ›å»ºï¼Œä½ åœ¨å†™è¿™äº›ä»£ç çš„æ—¶å€™ç”šè‡³ä¸çŸ¥é“è‡ªå·±å†™äº†ä¸€ä¸ªç²¾å¦™çš„é€’å½’ã€‚

è¦å®Œæˆè¿™ä¸ªé€’å½’ï¼Œæˆ‘ä»¬åªéœ€è¦å®šä¹‰ä¸¤ä¸ªæ–¹æ³•ï¼Œä¸€ä¸ªç”¨æ¥åˆ›å»ºå¯¹è±¡ï¼Œä¸€ä¸ªç”¨æ¥è·å–å¯¹è±¡ã€‚

```java
//å°†contextè¿”å›å‡ºå»æ˜¯ä¸ºäº†é“¾å¼è°ƒç”¨ï¼Œä¹Ÿå¯ä»¥ä¸è¿”å›Contextï¼Œå°†å®ƒä¿®æ”¹ä¸ºvoidå³å¯
public interface Context{
    /**
     * æä¾›ä¸€ä¸ªç±»å¯¹è±¡ï¼Œå¯»æ‰¾é‡Œé¢çš„å…¬å¼€æ„é€ ï¼Œåˆ›å»ºå‡ºå¯¹è±¡
     * @param type
     * @param name
     * @return
     */
    Context provide(Class<?> type, String name);

    /**
     * è·å–ä¸€ä¸ªå¯¹è±¡
     * @param type
     * @return
     * @param <T>
     */
    <T> T solver(Class<T> type);    
}
```

è®©æˆ‘ä»¬æ¥çœ‹çœ‹åˆ›å»ºå¯¹è±¡æ–¹æ³•çš„å…·ä½“é€»è¾‘

```java
    //åˆ›å»ºå®ä¾‹
   @Override
    public Context provide(Class<?> type, String name) {
        requireNonNull(type, "type is null");
        requireNonNull(name, "name is null");

        Object instance;
        try {
            final Object o = type.newInstance();
            instance = o;
        } catch (InstantiationException | IllegalAccessException e) {
            final var constructor = Arrays.stream(type.getConstructors())
                    .max(Comparator.comparingInt(Constructor::getParameterCount))
                    .orElseThrow(() -> new NullPointerException("no such public constructor"));
            final var args = Arrays.stream(constructor.getParameterTypes()).map(this::solver).toArray();
            try {
                instance = constructor.newInstance(args);
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                throw new RuntimeException(ex);
            }

        }
        provide(instance, name);
        return this;
    }
    //è·å–å®ä¾‹
    @Override
    @SuppressWarnings("unchecked")
    public <T> T solver(Class<T> type) {
        var pairs = super.context.get(type);
        if (isNull(pairs)) {
            provide(type);
            pairs = super.context.get(type);
        }
        requireNonNull(pairs, String.format("ç±»å‹%sä¸å­˜åœ¨", type.getSimpleName()));
        final var o = pairs.get(0).second();
        requireNonNull(o, String.format("ä¸%så¯¹åº”çš„å®ä¾‹ä¸å­˜åœ¨", type.getSimpleName()));
        return (T) o;
    }
```

provideæ–¹æ³•è·å–äº†ä¸¤ä¸ªå‚æ•°ï¼Œä¸€ä¸ªéœ€è¦è¢«åˆ›å»ºå‡ºæ¥çš„ç±»å‹ï¼Œä¸€ä¸ªæ˜¯ä¸ä¹‹å¯¹åº”çš„åç§°,å®ƒåšäº†ä¸¤ä»¶äº‹ï¼Œç›´æ¥ä½¿ç”¨æ— å‚æ„é€ è¿›è¡Œåˆ›å»ºå¯¹è±¡ï¼Œæ— æ³•åˆ›é€ å¯¹è±¡å°±ä½¿ç”¨å…¨å‚æ„é€ æ¥æŸ¥æ‰¾å‚æ•°å¹¶åˆ›å»ºå®ä¾‹ã€‚

æŸ¥æ‰¾çš„æ—¶å€™ä½¿ç”¨çš„æ˜¯`<T> T solver(Class<T> type)`æ–¹æ³•ï¼Œæˆ‘ä»¬åœ¨å¦‚æœåœ¨solveræ–¹æ³•ä¸­å‘ç°å½“å‰ç±»çš„å®ä¾‹è¿˜æ²¡è¢«åˆ›å»ºï¼Œåˆ™è°ƒç”¨`Context provide(Class<?> type)`è¿›è¡Œç±»çš„åˆ›å»ºã€‚

ä¸æ‰€æœ‰é€’å½’ä¸€æ ·ï¼Œå¦‚æœèƒ½æ‰¾åˆ°ä¸€ä¸ªå¯ç”¨çš„è§£ï¼Œåˆ™æ•´ä¸ªè¢«æ„å»ºç±»çš„æ„å»ºé“¾å°±ä¼šæ­£å¸¸è¿è½¬ï¼Œå¦‚æœæ— æ³•æ­£å¸¸è¿è½¬å°±è¡¨æ˜è¿™æ¡ä¾èµ–é“¾æ˜¯é”™è¯¯çš„ï¼Œåº”è¯¥å¥½å¥½æ€è€ƒè‡ªå·±çš„ä»£ç ä¾èµ–å…³ç³»äº†ã€‚
ï¼ˆå¦‚æœå‘ç°æœ‰äººå†™ä»£ç ä¾èµ–éƒ½èƒ½å†™å¾ªç¯ï¼Œè¿˜ä¸çŸ¥é“ä¸ºä»€ä¹ˆçš„ï¼Œé‚£å°±å¿«è·‘ğŸƒğŸš¨ï¼‰

è¿™ä¸¤ä¸ªæ˜¯iocå®¹å™¨æœ€æ ¸å¿ƒçš„æ–¹æ³•ï¼Œå…¶å®ƒçš„éƒ½æ˜¯é”¦ä¸Šæ·»èŠ±ï¼Œä¸è¦æ‹…å¿ƒæ•°æ®é‡æˆ–æ•°æ®ç»“æ„çš„å¤æ‚æ€§å¸¦æ¥çš„è€—æ—¶ï¼Œ
å› ä¸ºæœ€å¤§çš„è€—æ—¶æ°¸è¿œéƒ½åœ¨IOï¼Œåˆ›å»ºè¿™ä¹ˆç‚¹æ•°æ®ç‚¸ä¸äº†æœºå™¨ï¼Œå†…å­˜ä¹Ÿè¯¥ç”¨å°±ç”¨ã€‚

### åœ¨å·²è¢«åˆ›å»ºçš„å®ä¾‹æ± ä¸­é€šè¿‡æŸä¸€ç‰¹æ€§æ¥è·å–é›†åˆ

åœ¨ä¸‹é¢çš„å®Œæ•´ä»£ç ä¸­ï¼Œå®šä¹‰äº†è¿™ä¹ˆä¸€ä¸ªæ¥å£

```java
<T, Coll extends Collection<T>> Coll collect(Class<T> type, Supplier<? extends Coll> container);
```

åœ¨æˆ‘çš„å®šä¹‰ä¸­ï¼Œå®ƒé€šè¿‡æ¥æ”¶ä¸€ä¸ªclasså¯¹è±¡å’Œä¸€ä¸ªä¾›ç»™è€…ä¾›ç»™`Collection`æ–¹æ³•è¿›è¡Œè°ƒç”¨ï¼Œåˆ¤æ–­typeæ˜¯æ¥å£è¿˜æ˜¯ç±»å®šä¹‰æ¥è¿›è¡ŒæŸ¥æ‰¾å†…å®¹ï¼Œåœ¨æˆ‘çš„æ„æ€ä¸­ï¼Œåº”è¯¥åœ¨ä¸€ä¸ªåœ°æ–¹ä¸€æ¬¡å¯¹è¿™äº›å†…å®¹é…ç½®å®Œæ¯•ï¼Œä¸åº”è¯¥ä¸œä¸€ä¸ªï¼Œè¥¿ä¸€ä¸ªã€‚

æ‰€ä»¥æˆ‘å‡è®¾äº†åœ¨æ–¹æ³•è¿è¡Œå®Œæ¯•åï¼Œä¸åº”è¯¥å†æä¾›å†…å®¹ç»™å®¹å™¨ï¼Œæ‰€ä»¥æˆ‘åœ¨æŠ½è±¡ç±»ä¸­å®šä¹‰äº†ä¸€ä¸ªæŸ¥è¯¢ç¼“å­˜ï¼Œå…ˆå»ç¼“å­˜ä¸­æŸ¥æ‰¾ï¼Œç¼“å­˜ä¸­æ‰¾ä¸åˆ°å†å¼€å§‹è¿è¡ŒçœŸæ­£çš„æŸ¥è¯¢æ–¹æ³•ã€‚

ç”±äºJavaæ˜¯å¯è¢«æ“¦é™¤çš„æ³›å‹ï¼Œæ‰€ä»¥å°†å¸¦æ³›å‹æ¥å£ä¼ è¿›å»æŸ¥è¯¢å‡ºæ¥çš„å°†ä¼šæ˜¯æ˜¯æ‰€æœ‰å®ç°äº†è¯¥æ³›å‹çš„å¯¹è±¡ï¼Œéœ€è¦è‡ªè¡Œå¯¹å†…å®¹è¿›è¡Œåˆ¤æ–­ã€‚

**è¿™æ˜¯å®šä¹‰åœ¨æŠ½è±¡ç±»ä¸­çš„æŸ¥è¯¢æ–¹æ³•.**

```java
    protected final Map<Class<?>, Collection<Object>> cache = new HashMap<>();

    @SuppressWarnings("unchecked")
    protected <T> Collection<T> search(Class<T> type) {
        if (type == null) {
            throw new NullPointerException("type are null");
        }
        if (cache.containsKey(type)) {
            return (Collection<T>) cache.get(type);
        }
        if (type.isInterface()) {
            return searchByInterface(type);
        } else {
            return searchByType(type);
        }
    }

    /**
     * é€šè¿‡ç±»å‹æœç´¢
     *
     * @param type
     * @param <T>
     * @return
     */
    private <T> Collection<T> searchByType(Class<?> type) {
        return searchByAction(type, entry -> entry.getKey().equals(type));
    }

    /**
     * é€šè¿‡æ¥å£æœç´¢
     *
     * @param interfaceType
     * @param <T>
     * @return
     */
    private <T> Collection<T> searchByInterface(Class<?> interfaceType) {
        return searchByAction(interfaceType, entry -> Arrays.asList(entry.getKey().getInterfaces()).contains(interfaceType));
    }

    @SuppressWarnings("unchecked")
    private <T> Collection<T> searchByAction(Class<?> type, Predicate<Map.Entry<Class<?>, List<Pair<String, Object>>>> action) {
        try {
            final var result = context
                    .entrySet()
                    .stream()
                    .filter(action)
                    .map(Map.Entry::getValue)
                    .flatMap(Collection::stream)
                    .map(Pair::second)
                    .toList();
            cache.put(type, result);

            return (Collection<T>) result;
        } catch (Exception e) {
            return null;
        }
    }
```

é€šè¿‡ç±»å‹è¿›è¡Œæœç´¢å’Œé€šè¿‡æ¥å£è¿›è¡Œæœç´¢åªæœ‰åœ¨è¿‡æ»¤æ–¹æ³•æ‰ä¼šæœ‰å…·ä½“çš„å·®åˆ«ï¼Œæ‰€ä»¥æˆ‘å°†å…¶æŠ½è±¡å‡ºæ¥æˆä¸ºä¸€ä¸ªå•ç‹¬çš„æ–¹æ³•ï¼Œåˆ†åˆ«å®šä¹‰ä¸¤ä¸ªæ–¹æ³•çš„æœç´¢é€»è¾‘ï¼Œè¯¥`search`æ–¹æ³•ä¸ºå­ç±»æ–¹æ³•çš„`collect`è¿›è¡Œäº†æ”¯æŒã€‚

ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼Œå¯ä»¥å°†ä¸‹é¢ä¸‰ä¸ªå˜é‡æ‰“å°å‡ºæ¥çœ‹çœ‹å†…å®¹ã€‚

```java
final var context = AppContent.create("app")
                .provide("å§æ§½","config")
                .provide("2")
                .provide(1)
                .provide(3);
        final var strings = context.collect(String.class, ArrayList::new);
        final var integers = context.collect(Integer.class, ArrayList::new);
        final var charSequences = context.collect(CharSequence.class, ArrayList::new);
```

## å®Œæ•´ä»£ç 

```java
package com.cqsd.dl;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.function.Predicate;
import java.util.function.Supplier;

import static java.util.Objects.isNull;
import static java.util.Objects.requireNonNull;

/**
 * @author caseycheng
 * @date 2023/6/30-20:56
 **/
//ä½ç‰ˆæœ¬JavaæŠŠ sealed å’Œpermits BaseContext åˆ é™¤å³å¯
public sealed interface Context permits BaseContext {
    /**
     * æä¾›ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒçš„åå­—ä¸ºå®ƒè‡ªå·±çš„hashcode
     *
     * @param o
     * @return
     */
    Context provide(Object o);

    /**
     * æä¾›ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ç»™äºˆä¸€ä¸ªåå­—
     *
     * @param o
     * @param name
     * @return
     */
    Context provide(Object o, String name);

    /**
     * æä¾›ä¸€ä¸ªç±»å¯¹è±¡ï¼Œå¯»æ‰¾é‡Œé¢çš„å…¬å¼€æ„é€ ï¼Œåˆ›å»ºå‡ºå¯¹è±¡
     *
     * @param type
     * @param name
     * @return
     */
    Context provide(Class<?> type, String name);

    /**
     * æä¾›ä¸€ä¸ªç±»è®©dlè¿›è¡Œåˆ›å»º
     *
     * @param type
     * @return
     */
    Context provide(Class<?> type);

    /**
     * è·å–ä¸€ä¸ªå¯¹è±¡
     *
     * @param type
     * @param <T>
     * @return
     */
    <T> T solver(Class<T> type);

    /**
     * é€šè¿‡nameè·å–ä¸€ä¸ªå¯¹è±¡
     *
     * @param name
     * @param <T>
     * @return
     */
    <T> T solver(String name);

    /**
     * é€šè¿‡nameå’Œclassè·å–ä¸€ä¸ªå¯¹è±¡
     *
     * @param type
     * @param name
     * @param <T>
     * @return
     */
    <T> T solver(Class<T> type, String name);

    /**
     * è·å–æŸä¸ªç±»å‹çš„é›†åˆ
     * å¦‚æœæ˜¯æ¥å£ç±»å‹ï¼Œå°±æ£€ç´¢æ‰€æœ‰å€¼çš„è¯¥æ¥å£ï¼Œå¹¶è¿”å›é›†åˆ
     *
     * @param type      ç±»å‹
     * @param container éœ€è¦è¢«æ”¾å…¥çš„å®¹å™¨
     * @param <T>       ç±»å‹
     * @return å®¹å™¨
     */
    <T, Coll extends Collection<T>> Coll collect(Class<T> type, Supplier<? extends Coll> container);

    /**
     * è·å–ä¸Šä¸‹æ–‡åç§°
     *
     * @return
     */
    String getName();
}

record Pair<A, B>(A first, B second) {
    public static <A, B> Pair<A, B> createNotNull(A first, B second) {
        requireNonNull(first, "first is null");
        requireNonNull(second, "first is null");
        return new Pair<>(first, second);
    }

    public static <A, B> Pair<A, B> createNullable(A first, B second) {
        return new Pair<>(first, second);
    }
}
// ä¸æ”¯æŒrecordçš„ç”¨è¿™ä¸ªã€‚
class Pair<A,B>{
    private final A first;
    private final B second;

    private Pair(A first,B second){
        this.first=first;
        this.second=second;
    }

    public static <A, B> Pair<A, B> createNotNull(A first, B second) {
        requireNonNull(first, "first is null");
        requireNonNull(second, "first is null");
        return new Pair<>(first, second);
    }

    public static <A, B> Pair<A, B> createNullable(A first, B second) {
        return new Pair<>(first, second);
    }

}

//ä½ç‰ˆæœ¬jdkåˆ é™¤non-sealedå³å¯
abstract non-sealed class BaseContext implements Context {
    // env name
    private final String name;
    // map[key:class,value: List:name instance] ä¸å†™åå­—çš„å°±ç»™ä¸€ä¸ªç±»å‹åé¦–å­—æ¯å°å†™
    protected final Map<Class<?>, List<Pair<String, Object>>> context = new HashMap<>();
    //å¯¹[collection]æ¥å£çš„æŸ¥è¯¢ç¼“å­˜
    protected final Map<Class<?>, Collection<Object>> cache = new HashMap<>();

    public BaseContext(String envName) {
        requireNonNull(envName, "The name of the environment is required");
        this.name = envName;
    }

    /**
     * æä¾›ç»™å­ç±»è®¾ç½®å¯¹è±¡çš„æ–¹æ³•ï¼Œè¿™é‡Œåªç®¡æ·»åŠ 
     *
     * @param o    å®ä¾‹
     * @param name å®ä¾‹å
     */
    protected void addObject(Object o, String name) {
        final Class<?> key = o.getClass();
        if (!context.containsKey(key)) {
            context.put(key, new ArrayList<>());
        }
        context.get(key).add(Pair.createNotNull(name, o));
    }

    /**
     * é€šè¿‡ç±»å‹æˆ–æ¥å£è¿›è¡Œå¯»æ‰¾
     *
     * @param type
     * @param <T>
     * @return
     */
    @SuppressWarnings("unchecked")
    protected <T> Collection<T> search(Class<T> type) {
        if (type == null) {
            throw new NullPointerException("type are null");
        }
        if (cache.containsKey(type)) {
            return (Collection<T>) cache.get(type);
        }
        if (type.isInterface()) {
            return searchByInterface(type);
        } else {
            return searchByType(type);
        }
    }

    /**
     * é€šè¿‡ç±»å‹æœç´¢
     *
     * @param type
     * @param <T>
     * @return
     */
    private <T> Collection<T> searchByType(Class<?> type) {
        return searchByAction(type, entry -> entry.getKey().equals(type));
    }

    /**
     * é€šè¿‡æ¥å£æœç´¢
     *
     * @param interfaceType
     * @param <T>
     * @return
     */
    private <T> Collection<T> searchByInterface(Class<?> interfaceType) {
        return searchByAction(interfaceType, entry -> Arrays.asList(entry.getKey().getInterfaces()).contains(interfaceType));
    }

    @SuppressWarnings("unchecked")
    private <T> Collection<T> searchByAction(Class<?> type, Predicate<Map.Entry<Class<?>, List<Pair<String, Object>>>> action) {
        try {
            final var result = context
                    .entrySet()
                    .stream()
                    .filter(action)
                    .map(Map.Entry::getValue)
                    .flatMap(Collection::stream)
                    .map(Pair::second)
                    .toList();
            cache.put(type, result);

            return (Collection<T>) result;
        } catch (Exception e) {
            return null;
        }
    }


    @Override
    public String getName() {
        return this.name;
    }
}

class AppContent extends BaseContext {
    private AppContent(String envName) {
        super(envName);
    }

    public static Context create(String name) {
        return new AppContent(name);
    }

    /**
     * æä¾›ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒçš„åå­—ä¸ºå®ƒè‡ªå·±çš„hashcode
     *
     * @param o
     * @return
     */
    @Override
    public Context provide(Object o) {
        this.provide(o, String.valueOf(Objects.hashCode(o)));
        return this;
    }

    /**
     * æä¾›ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ç»™äºˆä¸€ä¸ªåå­—
     *
     * @param o
     * @param name
     * @return
     */
    @Override
    public Context provide(Object o, String name) {
        requireNonNull(o, "instance is null");

        super.addObject(o, name);
        return this;
    }

    /**
     * æä¾›ä¸€ä¸ªç±»å¯¹è±¡ï¼Œå¯»æ‰¾é‡Œé¢çš„å…¬å¼€æ„é€ ï¼Œåˆ›å»ºå‡ºå¯¹è±¡
     *
     * @param type
     * @param name
     * @return
     */
    @Override
    public Context provide(Class<?> type, String name) {
        requireNonNull(type, "type is null");
        requireNonNull(name, "name is null");

        Object instance;
        try {
            final Object o = type.newInstance();
            instance = o;
        } catch (InstantiationException | IllegalAccessException e) {
            final var constructor = Arrays.stream(type.getConstructors())
                    .max(Comparator.comparingInt(Constructor::getParameterCount))
                    .orElseThrow(() -> new NullPointerException("no such public constructor"));
            final var args = Arrays.stream(constructor.getParameterTypes()).map(this::solver).toArray();
            try {
                instance = constructor.newInstance(args);
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                throw new RuntimeException(ex);
            }

        }
        provide(instance, name);
        return this;
    }

    /**
     * æä¾›ä¸€ä¸ªç±»è®©dlè¿›è¡Œåˆ›å»º
     *
     * @param type
     * @return
     */
    @Override
    public Context provide(Class<?> type) {
        return provide(type, String.valueOf(Objects.hashCode(type)));
    }

    /**
     * è·å–ä¸€ä¸ªå¯¹è±¡
     *
     * @param type
     * @param <T>
     * @return
     */
    @Override
    @SuppressWarnings("unchecked")
    public <T> T solver(Class<T> type) {
        var pairs = super.context.get(type);
        if (isNull(pairs)) {
            provide(type);
            pairs = super.context.get(type);
        }
        requireNonNull(pairs, String.format("ç±»å‹%sä¸å­˜åœ¨", type.getSimpleName()));
        final var o = pairs.get(0).second();
        requireNonNull(o, String.format("ä¸%så¯¹åº”çš„å®ä¾‹ä¸å­˜åœ¨", type.getSimpleName()));
        return (T) o;
    }

    /**
     * é€šè¿‡nameè·å–ä¸€ä¸ªå¯¹è±¡
     *
     * @param name
     * @param <T>
     * @return
     */
    @Override
    @SuppressWarnings("unchecked")
    public <T> T solver(String name) {
        requireNonNull(name, "è¯·è¾“å…¥name");
        final var result = super.context.values()
                .stream()
                .flatMap(Collection::stream)
                .filter(pair -> pair.first().equals(name))
                .findFirst();
        result.orElseThrow(() -> new NullPointerException(String.format("åä¸º%sçš„å¯¹è±¡ä¸å­˜åœ¨", name)));
        return (T) result.get();
    }

    /**
     * é€šè¿‡nameå’Œclassè·å–ä¸€ä¸ªå¯¹è±¡
     *
     * @param type
     * @param name
     * @param <T>
     * @return
     */
    @Override
    @SuppressWarnings("unchecked")
    public <T> T solver(Class<T> type, String name) {
        requireNonNull(type, "type is null");
        requireNonNull(name, "name is null");
        final var list = super.context.get(type);
        requireNonNull(list, String.format("ç±»å‹ä¸º%sçš„å†…å®¹å°šæœªæä¾›", type.getSimpleName()));
        for (Pair<String, Object> pair : list) {
            if (pair.first().equals(name)) {
                return (T) pair.second();
            }
        }
        throw new NullPointerException(String.format("åä¸º%sçš„å¯¹è±¡ä¸å­˜åœ¨", name));
    }

    /**
     * è·å–æŸä¸ªç±»å‹çš„é›†åˆ
     * å¦‚æœæ˜¯æ¥å£ç±»å‹ï¼Œå°±æ£€ç´¢æ‰€æœ‰å€¼çš„è¯¥æ¥å£ï¼Œå¹¶è¿”å›é›†åˆ
     *
     * @param type      ç±»å‹
     * @param container éœ€è¦è¢«æ”¾å…¥çš„å®¹å™¨
     * @return å®¹å™¨
     */
    @Override
    public <T, Coll extends Collection<T>> Coll collect(Class<T> type, Supplier<? extends Coll> container) {
        final var result = super.search(type);
        final var ts = container.get();
        if (isNull(result)) {
            ts.addAll(Collections.emptyList());
        } else {
            ts.addAll(result);
        }
        return ts;
    }
}
```
