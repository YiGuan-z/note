# 一个即时通讯服务端（施工中）

## 前言

这几个月把kotlin的代码写熟了，所以就打算编写一个即时通讯服务来练练手。

发现一件事，通讯可以使用 MQTT来进行发送啊，那么我只需要提供登陆，好友列表查询，向列表发布即可，SQL可以删了，直接把数据放到redis中序列化，再配合MQTT来实现通讯。（正在学习swift-ui）

SQL不要了，redis就行，多存点关系就好。

留个地址怕忘记
[emqx](https://www.emqx.io)

- 用户功能
  - 单点登录
  - 私聊
  - 历史记录

---

- 群组功能
  - 管理员
    - 封锁聊天
    - 踢人
    - 拉人
  - 普通用户
    - 聊天
    - @用户

单点登录可以使用redis来记录用户信息。

历史记录直接存入数据库，保留一千条对话。

私聊转发一下数据即可，过程中存一次数据库。（如果用户在线，累计到redis中再批量入库，如果用户不在线，则直接放入待发送队列，同样是达到某个条件再入库）。

数据落地到PostgreSQL，要练一练ktorm框架使用。

选择使用kotlin平台进行开发，服务器采用ktor+Netty+ktorm+Lettuce+kodein+postgresql+druid

使用docker进行部署，docker-compose进行编排

用户表应有用户名，邮箱，密码，

好友表 用户对应的好友，存入对应id即可。

消息表 存储历史消息，这将会是最大的一张表，用户的历史会话记录一千条，多了就删除历史会话。（其实想用mongodb，但是ktorm不支持。）

## 注意

ktor的参数解析前缀需要 `-P:p=x` 这种格式才会进入环境中，并被解析为`p=x`,获取它的值需要`environment.config.property("p").getString()`，这对脚本化启动非常有帮助。
如果是环境变量的话，需要在配置中设置`$XX`然后在环境变量中对`$xx`进行设置.

## redis

- 消息首先写往redis缓存。
- 如果用户在线的话，则直接发送给用户。
- 历史消息由数据库消息和redis缓存中的消息求[并集](#并集)
- 用户请求过的历史消息也需要缓存起来。
- 用户上线后，开始从数据库读取数据并挨个推送给用户，一条消息推送成功就往redis中写入一个标记。
- 配置定时任务，定时将消息落入数据库中。
- 在数据落地的时候如果有对应的消息缓存集合和它对应的标记，则将缓存集合和它对应的标记进行属性合并，标记优先。
- 将redis包装到容器内部，不能对外访问，客户端用webSocket向服务器发送消息，服务器接收后将消息写入到对应缓存（路径为消息接收用户id，附上消息来源用户id，消息内容，消息发送时间），另一个客户端上线后就开始推送消息。
- 如果数据库中有未发送的消息，则与redis的消息缓存一同发送。

### 并集

A u B A={1,2,3} B={3,4,5} A u B = {1,2,3,4,5}

# 链接

[project](https://github.com/YiGuan-z/ktor-sample-Netty-chat.git)
写得烂，大佬别打，主要是用用这些技术。

[emqx](https://www.emqx.io)
